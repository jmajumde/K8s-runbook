Kubernetes Procedure Document
-----------------------------
Github repository [Read this first]
Download all the course material from: https://github.com/wardviaene/kubernetes-course

Kubernetes releases minor version updates of its distribution every 3 months

Rather than updating the scripts in the video lectures, the repository in Github is updated if any script need changes

The changes are often very minor, the API is very stable. Often API versions like v1betaX change to v1betaX+1 or to v1 (stable)

All the scripts you can find in the repository should work with the latest version of Kubernetes, if you have any issues, contact me through one of the channels listed below

Questions?
Send me a message

Use Q&A

Join our facebook group: https://www.facebook.com/groups/840062592768074/

Download Kubectl
Linux: https://storage.googleapis.com/kubernetes-release/release/v1.11.0/bin/linux/amd64/kubectl

MacOS: https://storage.googleapis.com/kubernetes-release/release/v1.11.0/bin/darwin/amd64/kubectl

Windows: https://storage.googleapis.com/kubernetes-release/release/v1.11.0/bin/windows/amd64/kubectl.exe

Or use a packaged version for your OS: see https://kubernetes.io/docs/tasks/tools/install-kubectl/

Minikube
Project URL: https://github.com/kubernetes/minikube

Latest Release and download instructions: https://github.com/kubernetes/minikube/releases

VirtualBox: http://www.virtualbox.org

Minikube on windows:
Download the latest minikube-version.exe

Rename the file to minikube.exe and put it in C:\minikube

Open a cmd (search for the app cmd or powershell)

Run: cd C:\minikube and enter minikube start

Test your cluster commands
Make sure your cluster is running, you can check with minikube status.

If your cluster is not running, enter minikube start first.

kubectl run hello-minikube --image=k8s.gcr.io/echoserver:1.4 --port=8080
kubectl expose deployment hello-minikube --type=NodePort

minikube service hello-minikube --url

<open a browser and go to that url>

Kops
Project URL
https://github.com/kubernetes/kops

Free DNS Service
Sign up at http://freedns.afraid.org/

Choose for subdomain hosting

Enter the AWS nameservers given to you in route53 as nameservers for the subdomain

http://www.dot.tk/ provides a free .tk domain name you can use and you can point it to the amazon AWS nameservers

Namecheap.com often has promotions for tld’s like .co for just a couple of bucks



Cluster Commands
----------------
> kops create cluster --name=kubernetes.majumder-jyotisekhar.me --state=s3://jm-kops-state --zones=us-east-1a --node-count=2 --node-size=t2.micro --master-size=t2.micro --dns-zone=kubernetes.majumder-jyotisekhar.me
> kops edit cluster kubernetes.majumder-jyotisekhar.me --state=s3://jm-kops-state

> kops update cluster kubernetes.majumder-jyotisekhar.me --yes --state=s3://jm-kops-state

> kops delete cluster --name kubernetes.majumder-jyotisekhar.me --state=s3://jm-kops-state

> kops delete cluster --name kubernetes.majumder-jyotisekhar.me --state=s3://jm-kops-state --yes
> kops get clusters --state=s3://jm-kops-state

 * validate cluster: kops validate cluster --state=s3://jm-kops-state
 * list nodes: kubectl get nodes --show-labels
 * ssh to the master: ssh -i ~/.ssh/id_rsa admin@api.kubernetes.majumder-jyotisekhar.me


new ssh-key upload
------------------
> kops create secret sshpublickey admin -i ~/.ssh/beast_rsa.pub --name kubernetes.majumder-jyotisekhar.me --state=s3://jm-kops-state
>kops delete secret SSHPublicKey admin1 a2:58:eb:30:5b:41:83:4a:c6:39:d4:33:65:5d:ec:9c --name kubernetes.majumder-jyotisekhar.me --state=s3://jm-kops-state
>kops update cluster kubernetes.majumder-jyotisekhar.me --yes --state=s3://jm-kops-state
>kops rolling-update cluster --name kubernetes.majumder-jyotisekhar.me --state=s3://jm-kops-state --yes


[ https://www.devops.buzz/kubernetes-start-and-stop-cluster-using-kops/ ]

> aws ec2 describe-instances --query 'Reservations[*].Instances[*].[InstanceId,State.Name,InstanceType,PrivateIpAddress,PublicIpAddress,Tags[?Key==`Name`].Value[]]' --output json | tr -d '\n[] "' | perl -pe 's/i-/\ni-/g' | tr ',' '\t' | sed -e 's/null/None/g' | grep '^i-' | column -t


deploy hello-minikube app in ec2 k8s cluster
---------------------------------------------
> kubectl run hello-minikube --image=k8s.gcr.io/echoserver:1.4 --port=8080
> kubectl expose deployment hello-minikube --type=NodePort
> kubectl get services


docker image/registry/push n deploy app in minikube
---------------------------------------------------
> cd /home/opc/jm-docker-demo
> docker build -t jmajumde/nodejs-helloworld-v1 .
> docker image list
> docker run -p 3000:3000 -it 674b6a3b4d71  -> to test

push the above image 

> docker login
> docker tag imageid jmajumde/nodejs-helloworld-v1 ===> not required, if -t is used in docker build
> docker push jmajumde/nodejs-helloworld-v1

Now deploy the first-app helloworld in minikube
------------------------------------------------
> minikube status

You can point your docker client to the VM's docker daemon by running. So that everytime kubectl does not try to pull the image from remote registry which speeds up pod provisioning. We need to mention "imagePullPolicy: IfNotPresent" in the pod provisioning yml specification. 

eval $(minikube docker-env)

But didnt work for me.

Alternatively we can create a secret for using remote registry like below, and mention "imagePullSecrets:" flag in the pod provisioning yml specification. This needs to be done for each pod that is using a private registry.
However, setting of this field can be automated by setting the imagePullSecrets in a serviceAccount resource. Check Add ImagePullSecrets to a Service Account (https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account) for detailed instructions.

> kubectl create secret docker-registry mydockerhubregistry --docker-server=https://hub.docker.com --docker-username=<user> --docker-password='<passwd>' --docker-email="<email>"
> kubectl get serviceaccounts
> kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "mydockerhubregistry"}]}'
> kubectl get serviceaccounts default -o json

> kubectl create -f ~/mywork/k8s-nonsense/first-app/helloworld.yml
> kubectl describe pod nodehelloworld.example.com

==== But this also does not work for me ====

to test the pod and the service initially we can test it by port-forward
> kubectl port-forward nodehelloworld.example.com 8081:3000

But its better to create a service for the pod. To create a service in minikube 
> kubectl expose pod nodehelloworld.example.com --type=NodePort --name nodehelloworld-service
> minikube service nodehelloworld-service --url


 
Kubernetes from scratch
------------------------
You can setup your cluster manually from scratch

If you’re planning to deploy on AWS / Google / Azure, use the tools that are fit for these platforms

If you have an unsupported cloud platform, and you still want Kubernetes, you can install it manually

CoreOS + Kubernetes: ###a href="https://coreos.com/kubernetes/docs/latest/getting-started.html">https://coreos.com/kubernetes/docs/latest/getting-started.html

Docker
You can download Docker Engine for:

Windows: https://docs.docker.com/engine/installation/windows/

MacOS: https://docs.docker.com/engine/installation/mac/

Linux: https://docs.docker.com/engine/installation/linux/


Cheatsheet: Kubernetes commands
-------------------------------
kubectl get pod: Get information about all running pods

kubectl describe pod <pod>: Describe one pod

kubectl expose pod <pod> --port=444 --name=frontend: Expose the port of a pod (creates a new service)

kubectl port-forward <pod> 8080: Port forward the exposed pod port to your local machine

kubectl attach <podname> -i: Attach to the pod

kubectl exec <pod> -- command: Execute a command on the pod
kubectl exec <pod> -- ls /app


kubectl label pods <pod> mylabel=awesome: Add a new label to a pod

kubectl run -i --tty busybox --image=busybox --restart=Never -- sh: Run a shell in a pod - very useful for debugging

kubectl get deployments: Get information on current deployments

kubectl get services

kubectl get rs: Get information about the replica sets

kubectl get pods --show-labels: get pods, and also show labels attached to those pods

kubectl rollout status deployment/helloworld-deployment: Get deployment status

kubectl set image deployment/helloworld-deployment k8s-demo=k8s-demo:2: Run k8s-demo with the image label version 2

kubectl edit deployment/helloworld-deployment: Edit the deployment object

kubectl rollout status deployment/helloworld-deployment: Get the status of the rollout

kubectl rollout history deployment/helloworld-deployment: Get the rollout history

kubectl rollout undo deployment/helloworld-deployment: Rollback to previous version

kubectl rollout undo deployment/helloworld-deployment --to-revision=n: Rollback to any version version

AWS Commands
aws ec2 create-volume --size 10 --region us-east-1 --availability-zone us-east-1a --volume-type gp2

Certificates
Creating a new key for a new user: openssl genrsa -out myuser.pem 2048

Creating a certificate request: openssl req -new -key myuser.pem -out myuser-csr.pem -subj "/CN=myuser/O=myteam/"

Creating a certificate: openssl x509 -req -in myuser-csr.pem -CA /path/to/kubernetes/ca.crt -CAkey /path/to/kubernetes/ca.key -CAcreateserial -out myuser.crt -days 10000

Abbreviations used
Resource type: Abbreviated alias

configmaps: cm

customresourcedefinition: crd

daemonsets: ds

deployments deploy

horizontalpodautoscalers: hpa

ingresses ing

limitranges limits

namespaces: ns

nodes: no

persistentvolumeclaims: pvc

persistentvolumes: pv

pods: po

replicasets: rs

replicationcontrollers: rc

resourcequotas: quota

serviceaccounts: sa

services: svc